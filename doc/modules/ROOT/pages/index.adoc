//
// Copyright (c) 2023 Vinnie Falco (vinnie.falco@gmail.com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at https://www.boost.org/LICENSE_1_0.txt)
//
// Official repository: https://github.com/cppalliance/http
//

= Boost.HTTP

HTTP powers the web, but implementing it correctly is surprisingly hard. Boost.HTTP
is a portable C++ library that provides containers and algorithms for the HTTP/1.1
protocol, giving you RFC-compliant message handling without the usual implementation
headaches.

== What This Library Does

* Provides modifiable containers for HTTP requests and responses
* Parses incoming HTTP messages with configurable limits
* Serializes outgoing messages with automatic chunked encoding
* Handles content encodings (gzip, deflate, brotli)
* Offers an Express.js-style router for request dispatch
* Enforces RFC 9110 compliance to prevent common security issues

== What This Library Does Not Do

* Network I/O — this is a Sans-I/O library by design
* HTTP/2 or HTTP/3 protocol support
* TLS/SSL handling
* Cookie management or session state
* Full HTTP client/server implementation (see Boost.Beast2 for I/O)

== Target Audience

This library is for C++ developers who need precise control over HTTP message
handling. You should have:

* Familiarity with TCP/IP networking concepts
* Understanding of the HTTP request/response model
* Experience with C++ move semantics and memory management

== Design Philosophy

The library follows a Sans-I/O architecture that separates protocol logic from
network operations. This design choice yields several benefits:

**Reusability.** The same protocol code works with any I/O framework — Asio,
io_uring, or platform-specific APIs. Write the HTTP logic once, integrate
it anywhere.

**Testability.** Tests run as pure function calls without sockets, timers,
or network delays. Coverage is higher, execution is faster, results are
deterministic.

**Security.** The parser is strict by default. Malformed input that could
enable request smuggling or header injection is rejected immediately.

== Requirements

* C++11 compiler (see tested compilers below)
* Boost libraries (core, system, optional)
* Link to the static or dynamic library

The library supports `-fno-exceptions` and detects this automatically.

=== Tested Compilers

* GCC: 5 to 14 (except 8.0.1)
* Clang: 3.9, 4 to 18
* MSVC: 14.1 to 14.42

== Code Conventions

Code examples in this documentation assume these declarations are in effect:

[source,cpp]
----
#include <boost/http.hpp>

using namespace boost::http;
----

== Quick Example

[source,cpp]
----
#include <boost/http.hpp>

using namespace boost::http;

int main()
{
    // Build a request
    request req(method::get, "/api/users");
    req.set(field::host, "example.com");
    req.set(field::accept, "application/json");

    // Build a response
    response res(status::ok);
    res.set(field::content_type, "application/json");
    res.set(field::content_length, "42");

    // Access the serialized form
    std::cout << req.buffer();
    std::cout << res.buffer();
}
----

Output:

----
GET /api/users HTTP/1.1
Host: example.com
Accept: application/json

HTTP/1.1 200 OK
Content-Type: application/json
Content-Length: 42

----

== Next Steps

* xref:http-protocol.adoc[Introduction to HTTP] — understand HTTP sessions and message flow
* xref:containers.adoc[Containers] — work with requests, responses, and fields
* xref:parsing.adoc[Parsing] — parse incoming HTTP messages
* xref:serializing.adoc[Serializing] — produce outgoing HTTP messages
* xref:router.adoc[Router] — dispatch requests to handlers
* xref:compression/zlib.adoc[ZLib Compression] — DEFLATE and gzip support
* xref:compression/brotli.adoc[Brotli Compression] — high-ratio compression

== Acknowledgments

This library wouldn't be where it is today without the help of
https://github.com/pdimov[Peter Dimov,window=blank_]
for design advice and general assistance.
